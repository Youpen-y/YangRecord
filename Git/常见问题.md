1. 如何切换提交邮箱？
首先，Git 的配置是分层级的，后一层级的配置会覆盖前一层级的。[[Git 使用#^3f1ed4]]
可以通过在仓库级（`--local`）设置 `user.name` 和 `user.email` 来覆盖全局级（`--global`）的设置。
修改 `.git/config` 文件，通过命令 `git config --list --local` 验证当前仓库使用的邮箱。
```bash
# .git/config
[user]
    name = YYP
    email = yypeng25@gmail.com
```

2. 如何添加 `Signed-off-by` 信息？
首先，`Signed-off-by` 信息是用来表明代码提交者或审阅者对该提交负责，并遵守相关的开发协议的一个声明。
`Signed-off-by` 是提交信息（Commit Message） 中的一行，格式如下：
```bash
Signed-off-by: name <email-address>

# 示例：
Signed-off-by: Yang YuPeng <yypeng25@gmail.com>
```
该行信息表示该提交人（或审阅者）确认自己有权提交该代码，并同意开源协议的相关条款。

如何产生 `Signed-off-by` 信息？
- 提交时生成。
```bash
git commit -s -m "提交信息"
```

- 生成补丁时产生。
```bash
git format-patch -s HEAD^
```


3. 当不小心错误 `merge` 时，如何处理？
假如一个 `feature` 分支，和一个 `main` 分支，正确的 `merge` 方案如下：
```bash
# 1. 切换到 main 分支
git checkout main

# 2. merge feature 分支
git merge feature
```
假如，我们不小心先签出到 `feature` 分支，然后 merge 了 `main` 分支。将呈现如下历史：
```
        /     |(HEAD -> *feature)
    /         |
/             |
|             |(*main)
```

补救方案：
一、`merge`
```bash
git checkout main
git merge feature
```
二、`reset`
```bash
git checkout feature
git reset --hard HEAD^
git checkout main
git merge feature
```

4. 复制本地仓库
- 备份本地仓库，包含工作区文件。
```bash
git clone work-repository backup
```

- 将本地仓库变为一个无工作区的裸仓库（base repository）
```bash
git clone --bare work-repository base-repository.git
```
裸仓库（bare repository）——目录中只有 `.git/` 的内容，没有工作区文件，通常用于作为中央仓库供多人推送。（惯例以 `.git` 结尾）
```bash
base-repository.git/
|--- HEAD
|--- config
|--- refs/
|--- objects/
|--- ...（与 .git 内部相同）
```

- 将裸仓库作为远程存储库添加到我们的原始存储库
```bash
# 在 work-repository 目录下
git remote add shared base-repository.git   # shared 是仓库名，类似于常规的 origin ，可自定义
```

4. `git pull` VS `git fetch`
```bash
git pull 
# 等价于
git fetch
git merge origin/main
```

5. 跨平台换行符问题？
Line endings（newline characters，换行符）用于指示文本文件中一行的结束。不同的操作系统使用不同的行尾约定。
- Windows 以回车符和换行符 `CR+LF`（`\r\n`） 的组合来表示新行。 
- macOS 和 Linux 以单个换行符 `LF` （`\n`）表示新行。
当开发人员跨不同平台开展项目时，这些行尾差异可能会导致问题，如意外的空格变化或合并期间的冲突。
Git 使用 `core.autocrlf` 来管理仓库中的行尾。可根据需要在全局、本地、或仓库级别设置该配置。
```bash
# 在将文件添加到存储库时将 CRLF 行尾转换为 LF，并保持 LF 行尾不变
git config --global core.autocrlf input 
# or
git config core.autocrlf input  # 仅为当前存储库设置 core.autocrlf 选项
```

或者，可以配置 `.gitattributes` 文件来管理在特定仓库中 Git 如何读取行尾。当你将此文件提交到仓库时，它会覆盖所有仓库贡献者的 `core.autocrlf` 设置。这可确保所有用户的行为一致，无论其 Git 设置和环境如何。
`.gitattributes` 特性：
- 在存储库的根目录下
- 看起来像一个包含两列的表
	- 左边是 Git 要匹配的文件名
	- 右边是 Git 应该对这些文件使用的行尾配置
示例：
```
# 设置默认行为，万一没有设置 core.autocrlf
* text=auto

# 显示地声明 text 文件（这些文件需要被规范化，在检出时转化为原生行末尾）
*.c text
*.h text

# 声明一些文件（这些文件必须以 CRLF 为行末尾）
*.sln text eol=crlf

# 指示一些文件是纯二进制，不应该被修改
*.png binary
*.jpg binary
```

6. 添加跟踪远程分支的本地分支
```bash
git branch --track greet origin/greet
Branch 'greet' set up to track remote branch 'greet' from 'origin'.
```

7. 在 `detached head`（分离头） 上进行了提交，怎么办？
Detached head（分离头）—— 特殊引用 `HEAD` 指向分支头以外的其他东西（如通过 `git checkout oldcommit`）。
问题：如果你提交到一个分离头，Git 会创建一个新的提交并将其附加到当前提交，形成一个分支。但这个分支没有名字！如果 checkout 到另一个分支，将无法通过其名称返回到该分支。
示例：
```bash
$ git checkout v1.0 
Note: switching to 'v1.0'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 5913170 Add feature1

```
如果在分离头上提交后，暂未切换到其他分支：
处理方案：
- 以当前提交作为头创建一个新分支： `git branch new-branch`
```bash
yongy@surge:/tmp/temp-project ((06515f6...))
$ git lg
* 7ca9452 - (test-feature, main) Add feature2 (5 hours ago) [Youpen-y]
* 9e3b938 - Fix feature1 (5 hours ago) [Youpen-y]
* 5913170 - (tag: v1.0) Add feature1 (5 hours ago) [Youpen-y]
* 9bd5d6f - First commit (5 hours ago) [Youpen-y]
yongy@surge:/tmp/temp-project ((06515f6...))
$ git branch new-branch
yongy@surge:/tmp/temp-project ((06515f6...))
$ git lg
* 06515f6 - (HEAD, new-branch) Commit on detached head (21 seconds ago) [Youpen-y]
| * 7ca9452 - (test-feature, main) Add feature2 (5 hours ago) [Youpen-y]
| * 9e3b938 - Fix feature1 (5 hours ago) [Youpen-y]
|/  
* 5913170 - (tag: v1.0) Add feature1 (5 hours ago) [Youpen-y]
* 9bd5d6f - First commit (5 hours ago) [Youpen-y]
```
- 将新的提交附加到另一个分支（假设是 `main` 分支）。记住新提交的 ID ，检出到 `main` 分支（`git checkout main`），`cherry-pick` 刚刚的提交（`git cherry-pick <ID>`）
如果在分离头上提交后，已经切换到其他分支：
可以使用 Git 的 `reflog` （`git reflog` 或 `git log -g`）。这将列出 `HEAD` 的历史记录（checkouts，commits 等），可从中获取提交 ID 。


实践：
1. 创建项目目录（project-name）并在其中进行裸克隆
```bash
mkdir project-name && cd project-name
git clone --bare <repo_url> .git/ 
```

2. 在当前目录创建多个 `worktree`
```bash
git worktree add production main
git worktree add feature_a feature_a
```

---
8. 当 PR 被合并后，主分支通常会有新的 merge commit，而 fork 分支还停留在 PR 提交的状态，会出现既领先又落后的情况，如何解决？
```bash
# 1. 添加上游仓库（如果还没添加的话）
git remote add upstream <原仓库的URL>

# 2. 获取上游仓库的最新更改
git fetch upstream

# 3. 切换到你的主分支（main）
git checkout main

# 4. rebase 到上游主分支
git rebase upstream/main

# 5. push
git push origin main --force-with-lease
```