### 概述
本文档介绍一些在 Linux 上用于修改进程映像（process images）的一些方法。
#### 相关概念
- 内存分配。一个进程通过某种方式在另一个进程的内存空间中分配或释放内存。适用场景：
	- 执行转向（Execution Diversion）：修改代码执行路径。通过操控另一个进程的内存，将其正常执行流重定向到自己注入的代码中。
	- 数据隐藏（Data Hiding）：在目标进程的内存映像中隐藏数据。
	- 动态分配结构/字符串：在目标进程中动态分配内存，用于存储新的数据结构或字符串。
- 内存管理。将一个进程的任意内存复制到另一个进程的任意地址，从而可以灵活地操作给定进程的内存映像。可用于拷贝字符串、函数、整数、Everything。
- 库注入（Library Injection）：将任意共享对象注入进程的能力允许可执行文件获取通常不会具有的符号，并允许恶意者可以注入任意的位置无关代码（Position-Independent Code，PIC）。
- 代码注入（Code Injection）：在目标进程中执行自定义的代码，并且控制它何时执行。本文介绍三种类型代码注入：
	- Forking（分叉注入）：进程创建子进程映像并执行任意代码。
	- Threading（线程注入）：进程创建执行任意功能的线程。
	- Function Trampolines（函数跳转注入）：对目标函数的调用跳转到任意代码然后跳转回原始函数。
#### 技术
- `ptrace`：`ptrace`（进程跟踪）API允许更改内存、读取内存、查看和设置寄存器以及单步执行进程。
- `/proc/[pid]/mem`：该技术虽在功能上比较有限，但不可忽视。通过 read/write 给定进程映像的能力，可以轻松地修改映像以进行“代码注入”。通过这种方法进行内存分配、管理和库注入等操作虽然更难，但并非不可能（理论上）。

#### 执行转移
为实现本文档中的大部分技术，需要将正在运行的进程的执行转移到我们控制的代码上。这需要考虑以下问题：
- 在哪里放置想要执行的代码？
基础知识：可执行文件包含符号（symbols）；符号映射到虚拟内存地址（vma），这些地址用于告诉虚拟内存管理器符号在内存中的具体位置。
> 符号（symbols）是程序中的标识符，用于指代函数、变量、类等。编译过程中，编译器会将这些符号记录在可执行文件中的符号表（Symbol Table）中。符号表是可执行文件的一部分，存储了符号名与其对应的内存地址等信息。Linux 中的 ELF（Executable and Linkable Format，可执行与链接格式）存储了符号表、程序段与动态连接信息。
示例：
```bash
$ objdump --syms ./a.out | grep main
0000000000000000       F *UND*  0000000000000000              __libc_start_main@GLIBC_2.34
0000000000001149 g     F .text  0000000000000023              main
```
这表明，程序执行时 `main()` 位于 `0000000000001149` 。考虑到 `main()` 函数是正常代码执行的‘门户’，它是任意代码的绝佳放置点。

```bash
objdump --section=.text --start-address=0x0000000000001149 --stop-address=0x0000000000001180 -d ./a.out

./a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1158:       48 89 c7                mov    %rax,%rdi
    115b:       b8 00 00 00 00          mov    $0x0,%eax
    1160:       e8 eb fe ff ff          call   1050 <printf@plt>
    1165:       b8 00 00 00 00          mov    $0x0,%eax
    116a:       5d                      pop    %rbp
    116b:       c3                      ret
```
当然，`main()` 并不总是入口点，但通过 `elf header` 的 `e_entry` 属性很容易找到入口点。
选择`main()`作为“放置点”的关键原因是：`main` 运行后，代码不会再次被访问（即 `main` 在程序启动时运行，一旦执行完毕，它的作用就结束了）； 

- 如何改变执行的过程？
为了改变进程的执行过程，需要掌握一些 `ptrace` 应用知识以及 `vm` 如何遍历可执行文件。在 x86 上，有一个 `vm` 寄存器（`eip`）用于保存下一条指令的 `vma`。一旦指令完成， `vm` 就会处理 `eip` 处的指令，并将 `eip` 增加当前指令的大小。有些指令（如 `jmp` 和 `call`）本身就是执行转移函数，它们会导致 `eip` 更改为操作数中指定的地址。该原理被用来将执行更改为我们想要执行的代码。
现在，假设理论上适用 “内存管理”部分的功能将我们自己的一些代码放在 `0000000000001149` （`main()` 地址）处。为了执行我们的代码，使用 `ptrace` 的 `PTRACE_SETREGS` 和 `PTRACE_GETREGS` 功能。这两种方法允许第三方进程获取寄存器并设置另一个进程的寄存器，包括 `eip` 。为更改执行过程，执行如下步骤：
1. 调用 `PTRACE_GETREGS` 来获取当前寄存器集
2. 将返回的寄存器组中的 `eip` 设置为 `0000000000001149`（我们代码的地址）
3. 使用我们修改的结构调用 `PTRACE_SETREGS` 
4. 继续执行过程

- 代码完成后如何恢复执行？
为恢复执行，需要稍微修改注入的代码。通常在末尾添加一条指令：
```assembly
int $0x3
```
在 Linux（和 Windows）上，它用于向活动调试器发出异常或断点信号。在 Linux 中，它会发送 `SIGTRAP`，如果正在跟踪进程，则 `wait()` 将捕获该信号。修改后代码看起来如下：
```assembly
 nop
 nop
 nop
 nop
 nop
 nop  

 mov $0x1, %eax # 任意代码示例
 #...
 
 int $0x3
 nop
```
代码顶部设置了一个 6 字节 `nop` 填充，以便我们更干净（更安全）地更改 `eip`，因为 `vm` 对我们的执行转移作出了反应。 `int $0x3` alerts 附加的调试器（`ptrace`），`nop` 用于填充，以便可以看到何时到达代码末尾。

整个过程：
1. 调用 `PTRACE_GETREGS` 获取 `current` 寄存器集
2. 将这些寄存器保存在另一个结构中，用于恢复
3. 将返回的寄存器组中的 `eip` 设置为 `0000000000001149`（我们代码的地址）
4. 使用修改后的结构调用 `PTRACE_SETREGS`
5. 继续执行，并使用 `wait()` 函数监视信号。如果 `wait()` 函数返回信号则信号为 stop 信号
	1. 调用 `PTRACE_GETREGS` 获取当前的寄存器集
	2. 如果 `eip` 等于（注入代码的大小 - 1），即末尾 `nop` 的位置，则说明已到达代码末尾。此时转到步骤 6 
	3. 否则，继续执行
6. 代码执行完成，使用步骤 2 中保存的结构调用 `PTRACE_SETREGS` 恢复执行

#### 内存分配
内存分配允许在另一个进程中动态分配内存。适用场景是将任意代码存储在内存中而不受大小限制。允许人们注入一个非常大的函数进行执行，而不必担心它们会溢出到另一个函数或有害位置。

第一件事是找出 `malloc` 在给定进程映像中的位置，以便我们可以调用它。
1. `malloc` 可能在哪里？


#### 内存管理
将内存从一个进程复制到另一个进程只需使用 `PTRACE_POKEDATA`，它允许将 4 个字节的数据写入进程内的给定地址。

#### 库注入
库注入在运行的进程中使用不该执行的功能时非常有效。其中一个更明显的应用是将个人开发的共享对象加载到正在运行的可执行文件中。
如何在二进制文件未链接到 libdl 的情况下加载库。libdl 提供了 dlopen()、dlsym() 和 dlclose() 等函数。问题是可执行文件默认不链接到此库。这意味着我们无法使用我们的神奇技巧来找出 dlopen 在内存中的位置，因为它不能保证在那里。